# 第7章	优雅地断开套接字连接

本章将讨论如何优雅地断开相互连接的套接字。之前用的方法不够优雅是因为，我们是调用close或closesocket函数单方买你断开连接的。



#### 7.1	基于TCP的半关闭

TCP中断开连接过程 比建立连接过程更重要，因为连接过程中一般不会出现大的边数，但断开过程有可能发生预想不到的情况，因此应准确掌控。只有掌握了下面要讲解的半关闭（Half-close），才能明确断开过程。

**单方面断开连接带来的问题**

LInux的close函数和Windows的closesocket函数意味着完全断开连接。完全断开不仅指无法传输数据，而且也不能接收数据。因此，在某种情况下，通信一方调用了close或者closesocket函数断开连接就显得不太优雅，如图7-1所示。

![图7-1]()

上图描述的是2态主机正在进行双向通信。主机A发送完最后的数据后，调用close函数断开了连接，之后主机A无法再接收主机B传输的数据。实际上，是完全无法调用与接收数据相关的函数。最终，由主机B传输的、主机A必须接收的数据也销毁了。

为了解决这类问题，“只关闭一部分数据交换中使用的流”（Half-close）的方法应运而生。断开一部分连接是指，可以传输数据但无法接收，或可以接收数据但无法传输。顾名思义就是只关闭流的一半。

**套接字和流（Stream）**

两台主机通过套接字建立连接后进入可交换数据的状态，又称“流形成的状态”。也就是把建立套接字后可交换数据的状态看作一种流。

此处的流可以比作水流。水朝着一个方向流动，同样，在套接字的流中，数据也只能向一个方向移动。因此，为了进行双向通信，需要如图7-2所示的2个流。

![图7-2]()

一旦两台主机间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。当然，其中一个主机的输入流与另一主机的输出流相连，而输出流则与另一主机的输入流相连。另外，本章讨论的“优雅地断开连接方式”只断开其中1个流，而非同时断开两个流。Linux的close和Windows的closesocket函数将同时断开两个流，因此与“优雅”儿子还有一段距离。

**针对优雅断开的shutdown函数**

接下来介绍用于半关闭的函数。下面这个shutdown函数就用来关闭其中1个流。

```c
#include <sys/socket.h>
int shutdown(int sock, int howto);
/*
 * 成功时返回0, 失败时返回-1
 * sock 需要断开的套接字文件描述符
 * howto 传递断开方式信息
 */
```

调用上述函数时，第二个参数决定断开连接的方式，其可能值如下所示。

- SHUT_RD：断开输入流。
- SHUT_WR：断开输出流。
- SHUT_RDWR：同时断开I/O流。

若向shutdown的第二个参数传递SHUT_RD，则断开输入流，套接字无法接收数据。即使输入缓冲收到数据也会抹去，而且无法调用输入相关函数。如果向shutdown函数的第二个参数传递SHUT_WR，则中断输出流，也就无法传输数据。但如果输出缓冲还留有未传输的数据，则将传递至目标主机。最后，若传入SHUT_RDWR，则同时中断I/O流。这相当与调用2次shutdown函数。

**为何需要半关闭**

相信各位已对“关闭套接字的一半连接”有了充分的认识，但还有一些疑惑。

> “究竟为什么需要半关闭？是否只要留出足够长的连接时间，保证完成数据交换即可？只要不急于断开连接，好像也没必要使用半关闭。

这句话也不完全是错的。如果保持足够的时间间隔，完成数据交换后再断开连接，这时就没必要使用半关闭。但要考虑如下情况：

> ”一旦客户端连接到服务器端，服务器端将约定的文件传给客户端，客户端收到后发送字符串“Thank you”给服务器端。“

此处字符串”Thank you“的传递实际是多余的，这只是用来模拟客户端断开连接前还有数据需要传递的情况。此时程序实现的难度并不小，因为传输文件的服务器端只需连续传输文件数据即可，而客户端则无法知道需要接收数据到何时。客户端也没有办法无休止地调用输入函数，因为这又可能导致程序阻塞（调用的函数未返回）。

> ”是否可以让服务器端和客户端约定一个代表文件尾的字符？“

这种方式也有问题，因为这意味着文件中不能有与约定字符相同的内容。为解决该问题，服务器端应最后向客户端传递EOF表示文件传输结束。客户端通过函数返回值接收EOF，这样可以避免与文件的内容冲突。剩下最后一个问题：服务器如何传递EOF？

> ”断开输出流时向对方主机传输EOF。“

当然，调用close函数的同时关闭I/O流，这样也会向对方发送EOF。但此时无法在接收对方传输的数据。换言之，若调用close函数关闭流，就无法接收客户端最后发送的字符串”Thank you“。这时需要调用shutdown函数，值关闭服务器的输出流（半关闭）。这样既可以发送EOF，同时又保留了输入流，可以接收对方数据。下面结合已学内容实现收发文件的服务器端/客户端。

**基于半关闭的文件传输程序**

上述文件传输服务器端和客户端的数据流可整理如图7-3,稍后将根据此图编写示例。希望各位通过此例理解传递EOF的必要性和半关闭的重要性。

![图7-3]()

首先介绍服务器端。该示例与之前示例不同，省略了大量错误处理代码，希望大家注意。这种处理只是为了便于分析代码，实际编写中不应省略。

[file_server.c]()

[file_client.c]()

下面是上述示例的运行结果。运行后查看客户端的receive.dat文件，可以验证数据正常接收。特别需要注意的是，还可以确认服务器端已正常接收客户端最后传输的消息”Thank you“。

![运行结果2]()